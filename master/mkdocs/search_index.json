{
    "docs": [
        {
            "location": "/", 
            "text": "Foobar\n\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Donec elementum massa purus, ut tristique ex ultrices at. Praesent ac diam dui. Nulla facilisi. Nullam faucibus sollicitudin mi non porttitor. In nec imperdiet risus, cursus consequat leo. Nunc sit amet ex sed lacus feugiat elementum quis nec tellus. Praesent at ante non ligula interdum lacinia. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vivamus ultricies vitae leo quis maximus.\n\n\nFoobar Foobar\n\n\nNulla dapibus accumsan mi, in porta ex congue viverra. Ut egestas auctor lectus. Fusce urna nulla, vulputate sit amet turpis a, mollis lobortis velit. Praesent ac pulvinar augue, eu iaculis sapien. Morbi sollicitudin lacus ut mauris porta elementum. Sed dapibus, magna congue semper tincidunt, nisi justo bibendum nulla, fermentum pharetra tellus nulla congue dui. Morbi mollis tellus a libero viverra, ut aliquam dui tempus. Curabitur vestibulum elit ultricies porta ultrices. Maecenas blandit, lectus non vestibulum sodales, est lorem sollicitudin libero, in accumsan urna velit vitae metus. Mauris gravida non ante vel consectetur. Vestibulum finibus suscipit magna, vel fermentum est rutrum vitae. Donec luctus condimentum imperdiet.\n\n\npackage httpstream\n\nimport (\n    \nencoding/json\n\n    \nfmt\n\n    \nlog\n\n    \nnet/http\n\n    \nos\n\n    \nstrconv\n\n\n    \ncode.google.com/p/go.net/websocket\n\n    \ngithub.com/gorilla/mux\n\n\n    \ngithub.com/gliderlabs/logspout/router\n\n)\n\nfunc init() {\n    router.HttpHandlers.Register(LogStreamer, \nlogs\n)\n}\n\nfunc debug(v ...interface{}) {\n    if os.Getenv(\nDEBUG\n) != \n {\n        log.Println(v...)\n    }\n}\n\nfunc LogStreamer() http.Handler {\n    logs := mux.NewRouter()\n    logsHandler := func(w http.ResponseWriter, req *http.Request) {\n        params := mux.Vars(req)\n        route := new(router.Route)\n\n        if params[\nvalue\n] != \n {\n            switch params[\npredicate\n] {\n            case \nid\n:\n                route.FilterID = params[\nvalue\n]\n                if len(route.ID) \n 12 {\n                    route.FilterID = route.FilterID[:12]\n                }\n            case \nname\n:\n                route.FilterName = params[\nvalue\n]\n            }\n        }\n\n        if route.FilterID != \n \n !router.Routes.RoutingFrom(route.FilterID) {\n            http.NotFound(w, req)\n            return\n        }\n\n        defer debug(\nhttp: logs streamer disconnected\n)\n        logstream := make(chan *router.Message)\n        defer close(logstream)\n\n        var closer \n-chan bool\n        if req.Header.Get(\nUpgrade\n) == \nwebsocket\n {\n            debug(\nhttp: logs streamer connected [websocket]\n)\n            closerBi := make(chan bool)\n            defer websocketStreamer(w, req, logstream, closerBi)\n            closer = closerBi\n        } else {\n            debug(\nhttp: logs streamer connected [http]\n)\n            defer httpStreamer(w, req, logstream, route.MultiContainer())\n            closer = w.(http.CloseNotifier).CloseNotify()\n        }\n        route.OverrideCloser(closer)\n\n        router.Routes.Route(route, logstream)\n    }\n    logs.HandleFunc(\n/logs/{predicate:[a-zA-Z]+}:{value}\n, logsHandler).Methods(\nGET\n)\n    logs.HandleFunc(\n/logs\n, logsHandler).Methods(\nGET\n)\n    return logs\n}\n\ntype Colorizer map[string]int\n\n// returns up to 14 color escape codes (then repeats) for each unique key\nfunc (c Colorizer) Get(key string) string {\n    i, exists := c[key]\n    if !exists {\n        c[key] = len(c)\n        i = c[key]\n    }\n    bright := \n1;\n\n    if i%14 \n 6 {\n        bright = \n\n    }\n    return \n\\x1b[\n + bright + \n3\n + strconv.Itoa(7-(i%7)) + \nm\n\n}\n\nfunc marshal(obj interface{}) []byte {\n    bytes, err := json.MarshalIndent(obj, \n, \n  \n)\n    if err != nil {\n        log.Println(\nmarshal:\n, err)\n    }\n    return bytes\n}\n\nfunc normalName(name string) string {\n    return name[1:]\n}\n\nfunc websocketStreamer(w http.ResponseWriter, req *http.Request, logstream chan *router.Message, closer chan bool) {\n    websocket.Handler(func(conn *websocket.Conn) {\n        for logline := range logstream {\n            if req.URL.Query().Get(\nsource\n) != \n \n logline.Source != req.URL.Query().Get(\nsource\n) {\n                continue\n            }\n            _, err := conn.Write(append(marshal(logline), '\\n'))\n            if err != nil {\n                closer \n- true\n                return\n            }\n        }\n    }).ServeHTTP(w, req)\n}\n\nfunc httpStreamer(w http.ResponseWriter, req *http.Request, logstream chan *router.Message, multi bool) {\n    var colors Colorizer\n    var usecolor, usejson bool\n    nameWidth := 16\n    if req.URL.Query().Get(\ncolors\n) != \noff\n {\n        colors = make(Colorizer)\n        usecolor = true\n    }\n    if req.Header.Get(\nAccept\n) == \napplication/json\n {\n        w.Header().Add(\nContent-Type\n, \napplication/json\n)\n        usejson = true\n    } else {\n        w.Header().Add(\nContent-Type\n, \ntext/plain\n)\n    }\n    for logline := range logstream {\n        if req.URL.Query().Get(\nsources\n) != \n \n logline.Source != req.URL.Query().Get(\nsources\n) {\n            continue\n        }\n        if usejson {\n            w.Write(append(marshal(logline), '\\n'))\n        } else {\n            if multi {\n                name := normalName(logline.Container.Name)\n                if len(name) \n nameWidth {\n                    nameWidth = len(name)\n                }\n                if usecolor {\n                    w.Write([]byte(fmt.Sprintf(\n                        \n%s%\n+strconv.Itoa(nameWidth)+\ns|%s\\x1b[0m\\n\n,\n                        colors.Get(name), name, logline.Data,\n                    )))\n                } else {\n                    w.Write([]byte(fmt.Sprintf(\n                        \n%\n+strconv.Itoa(nameWidth)+\ns|%s\\n\n, name, logline.Data,\n                    )))\n                }\n            } else {\n                w.Write(append([]byte(logline.Data), '\\n'))\n            }\n        }\n        w.(http.Flusher).Flush()\n    }\n}\n\n\n\n\nNullam rutrum nisi non velit iaculis, eu condimentum nibh placerat. Cras eu urna eu nunc pharetra gravida non id ex. Vestibulum at dictum sapien. Quisque tristique, erat pretium venenatis fermentum, sapien mauris suscipit arcu, nec sollicitudin dui diam vel ipsum. Duis eleifend nisi id ultricies imperdiet. Sed viverra metus vel mi tincidunt cursus. Suspendisse nulla risus, aliquam at mollis vitae, porttitor sed quam. Sed sit amet magna tortor. Suspendisse potenti. Phasellus ante orci, sagittis tincidunt luctus sit amet, dapibus vitae augue. Maecenas elementum dignissim augue eu dignissim. Integer molestie, sem quis rhoncus semper, lectus diam sollicitudin ligula, vel euismod tellus tortor non libero. Phasellus ac nibh vitae nulla varius porta eu vitae mauris. Morbi mattis tincidunt arcu et dapibus.\n\n\n\n\n\n\n\n\nFirst Header\n\n\nSecond Header\n\n\nThird Header\n\n\n\n\n\n\n\n\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell\n\n\n\n\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell\n\n\n\n\n\n\n\n\nMaecenas iaculis est dignissim leo lobortis varius. Aliquam at condimentum enim. Cras et tincidunt enim. In quis dapibus magna. Sed sed tellus sem. Curabitur vel justo leo. Sed eget tincidunt nisl. Sed nec lacus at massa sollicitudin bibendum vel vel nibh. Vivamus finibus erat vel tempor rutrum.\n\n\nCras blandit imperdiet sem, vel viverra est tincidunt sed. Sed sapien dui, pretium in ornare in, semper vel orci. Maecenas a quam velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Nulla egestas, diam id venenatis porta, mauris massa hendrerit felis, eu tristique leo urna egestas tortor. Vestibulum vel turpis ante. Etiam vulputate in lectus ut lobortis. Aenean semper, tellus lacinia porttitor dapibus, diam nibh rhoncus quam, vitae interdum sapien eros quis augue. Nam id odio suscipit, congue velit vel, maximus ligula. Vestibulum feugiat fringilla posuere.", 
            "title": "Home"
        }, 
        {
            "location": "/#foobar", 
            "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec elementum massa purus, ut tristique ex ultrices at. Praesent ac diam dui. Nulla facilisi. Nullam faucibus sollicitudin mi non porttitor. In nec imperdiet risus, cursus consequat leo. Nunc sit amet ex sed lacus feugiat elementum quis nec tellus. Praesent at ante non ligula interdum lacinia. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vivamus ultricies vitae leo quis maximus.", 
            "title": "Foobar"
        }, 
        {
            "location": "/#foobar-foobar", 
            "text": "Nulla dapibus accumsan mi, in porta ex congue viverra. Ut egestas auctor lectus. Fusce urna nulla, vulputate sit amet turpis a, mollis lobortis velit. Praesent ac pulvinar augue, eu iaculis sapien. Morbi sollicitudin lacus ut mauris porta elementum. Sed dapibus, magna congue semper tincidunt, nisi justo bibendum nulla, fermentum pharetra tellus nulla congue dui. Morbi mollis tellus a libero viverra, ut aliquam dui tempus. Curabitur vestibulum elit ultricies porta ultrices. Maecenas blandit, lectus non vestibulum sodales, est lorem sollicitudin libero, in accumsan urna velit vitae metus. Mauris gravida non ante vel consectetur. Vestibulum finibus suscipit magna, vel fermentum est rutrum vitae. Donec luctus condimentum imperdiet.  package httpstream\n\nimport (\n     encoding/json \n     fmt \n     log \n     net/http \n     os \n     strconv \n\n     code.google.com/p/go.net/websocket \n     github.com/gorilla/mux \n\n     github.com/gliderlabs/logspout/router \n)\n\nfunc init() {\n    router.HttpHandlers.Register(LogStreamer,  logs )\n}\n\nfunc debug(v ...interface{}) {\n    if os.Getenv( DEBUG ) !=   {\n        log.Println(v...)\n    }\n}\n\nfunc LogStreamer() http.Handler {\n    logs := mux.NewRouter()\n    logsHandler := func(w http.ResponseWriter, req *http.Request) {\n        params := mux.Vars(req)\n        route := new(router.Route)\n\n        if params[ value ] !=   {\n            switch params[ predicate ] {\n            case  id :\n                route.FilterID = params[ value ]\n                if len(route.ID)   12 {\n                    route.FilterID = route.FilterID[:12]\n                }\n            case  name :\n                route.FilterName = params[ value ]\n            }\n        }\n\n        if route.FilterID !=     !router.Routes.RoutingFrom(route.FilterID) {\n            http.NotFound(w, req)\n            return\n        }\n\n        defer debug( http: logs streamer disconnected )\n        logstream := make(chan *router.Message)\n        defer close(logstream)\n\n        var closer  -chan bool\n        if req.Header.Get( Upgrade ) ==  websocket  {\n            debug( http: logs streamer connected [websocket] )\n            closerBi := make(chan bool)\n            defer websocketStreamer(w, req, logstream, closerBi)\n            closer = closerBi\n        } else {\n            debug( http: logs streamer connected [http] )\n            defer httpStreamer(w, req, logstream, route.MultiContainer())\n            closer = w.(http.CloseNotifier).CloseNotify()\n        }\n        route.OverrideCloser(closer)\n\n        router.Routes.Route(route, logstream)\n    }\n    logs.HandleFunc( /logs/{predicate:[a-zA-Z]+}:{value} , logsHandler).Methods( GET )\n    logs.HandleFunc( /logs , logsHandler).Methods( GET )\n    return logs\n}\n\ntype Colorizer map[string]int\n\n// returns up to 14 color escape codes (then repeats) for each unique key\nfunc (c Colorizer) Get(key string) string {\n    i, exists := c[key]\n    if !exists {\n        c[key] = len(c)\n        i = c[key]\n    }\n    bright :=  1; \n    if i%14   6 {\n        bright =  \n    }\n    return  \\x1b[  + bright +  3  + strconv.Itoa(7-(i%7)) +  m \n}\n\nfunc marshal(obj interface{}) []byte {\n    bytes, err := json.MarshalIndent(obj,  ,     )\n    if err != nil {\n        log.Println( marshal: , err)\n    }\n    return bytes\n}\n\nfunc normalName(name string) string {\n    return name[1:]\n}\n\nfunc websocketStreamer(w http.ResponseWriter, req *http.Request, logstream chan *router.Message, closer chan bool) {\n    websocket.Handler(func(conn *websocket.Conn) {\n        for logline := range logstream {\n            if req.URL.Query().Get( source ) !=     logline.Source != req.URL.Query().Get( source ) {\n                continue\n            }\n            _, err := conn.Write(append(marshal(logline), '\\n'))\n            if err != nil {\n                closer  - true\n                return\n            }\n        }\n    }).ServeHTTP(w, req)\n}\n\nfunc httpStreamer(w http.ResponseWriter, req *http.Request, logstream chan *router.Message, multi bool) {\n    var colors Colorizer\n    var usecolor, usejson bool\n    nameWidth := 16\n    if req.URL.Query().Get( colors ) !=  off  {\n        colors = make(Colorizer)\n        usecolor = true\n    }\n    if req.Header.Get( Accept ) ==  application/json  {\n        w.Header().Add( Content-Type ,  application/json )\n        usejson = true\n    } else {\n        w.Header().Add( Content-Type ,  text/plain )\n    }\n    for logline := range logstream {\n        if req.URL.Query().Get( sources ) !=     logline.Source != req.URL.Query().Get( sources ) {\n            continue\n        }\n        if usejson {\n            w.Write(append(marshal(logline), '\\n'))\n        } else {\n            if multi {\n                name := normalName(logline.Container.Name)\n                if len(name)   nameWidth {\n                    nameWidth = len(name)\n                }\n                if usecolor {\n                    w.Write([]byte(fmt.Sprintf(\n                         %s% +strconv.Itoa(nameWidth)+ s|%s\\x1b[0m\\n ,\n                        colors.Get(name), name, logline.Data,\n                    )))\n                } else {\n                    w.Write([]byte(fmt.Sprintf(\n                         % +strconv.Itoa(nameWidth)+ s|%s\\n , name, logline.Data,\n                    )))\n                }\n            } else {\n                w.Write(append([]byte(logline.Data), '\\n'))\n            }\n        }\n        w.(http.Flusher).Flush()\n    }\n}  Nullam rutrum nisi non velit iaculis, eu condimentum nibh placerat. Cras eu urna eu nunc pharetra gravida non id ex. Vestibulum at dictum sapien. Quisque tristique, erat pretium venenatis fermentum, sapien mauris suscipit arcu, nec sollicitudin dui diam vel ipsum. Duis eleifend nisi id ultricies imperdiet. Sed viverra metus vel mi tincidunt cursus. Suspendisse nulla risus, aliquam at mollis vitae, porttitor sed quam. Sed sit amet magna tortor. Suspendisse potenti. Phasellus ante orci, sagittis tincidunt luctus sit amet, dapibus vitae augue. Maecenas elementum dignissim augue eu dignissim. Integer molestie, sem quis rhoncus semper, lectus diam sollicitudin ligula, vel euismod tellus tortor non libero. Phasellus ac nibh vitae nulla varius porta eu vitae mauris. Morbi mattis tincidunt arcu et dapibus.     First Header  Second Header  Third Header      Content Cell  Content Cell  Content Cell    Content Cell  Content Cell  Content Cell     Maecenas iaculis est dignissim leo lobortis varius. Aliquam at condimentum enim. Cras et tincidunt enim. In quis dapibus magna. Sed sed tellus sem. Curabitur vel justo leo. Sed eget tincidunt nisl. Sed nec lacus at massa sollicitudin bibendum vel vel nibh. Vivamus finibus erat vel tempor rutrum.  Cras blandit imperdiet sem, vel viverra est tincidunt sed. Sed sapien dui, pretium in ornare in, semper vel orci. Maecenas a quam velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Nulla egestas, diam id venenatis porta, mauris massa hendrerit felis, eu tristique leo urna egestas tortor. Vestibulum vel turpis ante. Etiam vulputate in lectus ut lobortis. Aenean semper, tellus lacinia porttitor dapibus, diam nibh rhoncus quam, vitae interdum sapien eros quis augue. Nam id odio suscipit, congue velit vel, maximus ligula. Vestibulum feugiat fringilla posuere.", 
            "title": "Foobar Foobar"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nabout about about", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "about about about", 
            "title": "About"
        }
    ]
}